package org.example.service;

import lombok.Getter;
import lombok.Setter;

import java.io.*;
import java.nio.file.*;
import java.sql.*;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

public class BackupService {
    private final DatabaseService databaseService;
    private static final String BACKUP_DIR = "backup";
    private static final String DATE_FORMAT = "yyyyMMdd_HHmmss";

    public BackupService(DatabaseService databaseService) {
        this.databaseService = databaseService;
        createBackupDirectory();
    }

    private void createBackupDirectory() {
        try {
            Path backupPath = Paths.get(BACKUP_DIR);
            if (!Files.exists(backupPath)) {
                Files.createDirectories(backupPath);
                System.out.println("Created backup directory: " + backupPath.toAbsolutePath());
            }
        } catch (IOException e) {
            System.err.println("Error creating backup directory: " + e.getMessage());
        }
    }

    public BackupResult createBackup() {
        BackupResult result = new BackupResult();

        try (Connection conn = databaseService.getConnection()) {
            String schema = databaseService.getCurrentSchema();
            String timestamp = new SimpleDateFormat(DATE_FORMAT).format(new Date());
            String backupFileName = String.format("backup_%s_%s.sql", schema, timestamp);
            Path backupPath = Paths.get(BACKUP_DIR, backupFileName);

            try (PrintWriter writer = new PrintWriter(new FileWriter(backupPath.toFile()))) {
                writer.println("-- PostgreSQL Backup");
                writer.println("-- Schema: " + schema);
                writer.println("-- Date: " + new Date());
                writer.println("-- Generated by Database Manager");
                writer.println();

                List<String> tables = databaseService.getTablesInCurrentSchema();

                if (tables.isEmpty()) {
                    result.setSuccess(false);
                    result.setMessage("No tables found in schema: " + schema);
                    return result;
                }

                for (String table : tables) {
                    backupTable(conn, table, writer);
                }

                result.setSuccess(true);
                result.setMessage("Backup created successfully: " + backupFileName);
                result.setBackupFile(backupPath.toFile());
                result.setTablesCount(tables.size());

            } catch (IOException e) {
                result.setSuccess(false);
                result.setMessage("Error writing backup file: " + e.getMessage());
            }

        } catch (SQLException e) {
            result.setSuccess(false);
            result.setMessage("Database error during backup: " + e.getMessage());
        }

        return result;
    }

    public BackupResult createTableBackup(String tableName) {
        BackupResult result = new BackupResult();

        try (Connection conn = databaseService.getConnection()) {
            String schema = databaseService.getCurrentSchema();
            String timestamp = new SimpleDateFormat(DATE_FORMAT).format(new Date());
            String backupFileName = String.format("backup_%s_%s_%s.sql", schema, tableName, timestamp);
            Path backupPath = Paths.get(BACKUP_DIR, backupFileName);

            try (PrintWriter writer = new PrintWriter(new FileWriter(backupPath.toFile()))) {
                writer.println("-- PostgreSQL Table Backup");
                writer.println("-- Schema: " + schema);
                writer.println("-- Table: " + tableName);
                writer.println("-- Date: " + new Date());
                writer.println();

                backupTable(conn, tableName, writer);

                result.setSuccess(true);
                result.setMessage("Table backup created successfully: " + backupFileName);
                result.setBackupFile(backupPath.toFile());
                result.setTablesCount(1);

            } catch (IOException e) {
                result.setSuccess(false);
                result.setMessage("Error writing backup file: " + e.getMessage());
            }

        } catch (SQLException e) {
            result.setSuccess(false);
            result.setMessage("Database error during backup: " + e.getMessage());
        }

        return result;
    }

    private void backupTable(Connection conn, String tableName, PrintWriter writer) throws SQLException {
        writer.println("-- Table: " + tableName);
        writer.println("-- Structure");

        writer.println("DROP TABLE IF EXISTS " + tableName + " CASCADE;");

        backupSequences(conn, tableName, writer);
        try (Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(
                     "SELECT column_name, data_type, character_maximum_length, " +
                             "is_nullable, column_default " +
                             "FROM information_schema.columns " +
                             "WHERE table_schema = '" + databaseService.getCurrentSchema() + "' " +
                             "AND table_name = '" + tableName + "' " +
                             "ORDER BY ordinal_position")) {

            writer.println("CREATE TABLE " + tableName + " (");
            List<String> columns = new ArrayList<>();
            while (rs.next()) {
                String columnName = rs.getString("column_name");
                String dataType = rs.getString("data_type");
                String maxLength = rs.getString("character_maximum_length");
                String isNullable = rs.getString("is_nullable");
                String defaultValue = rs.getString("column_default");

                StringBuilder columnDef = new StringBuilder("  " + columnName + " " + dataType);

                if (maxLength != null && !maxLength.isEmpty()) {
                    columnDef.append("(").append(maxLength).append(")");
                }

                if ("NO".equals(isNullable)) {
                    columnDef.append(" NOT NULL");
                }

                if (defaultValue != null && !defaultValue.isEmpty()) {
                    if (defaultValue.contains("nextval") && dataType.equals("integer")) {
                        columnDef = new StringBuilder("  " + columnName + " SERIAL");
                    } else {
                        String cleanDefault = cleanupDefaultValue(defaultValue);
                        columnDef.append(" DEFAULT ").append(cleanDefault);
                    }
                }

                columns.add(columnDef.toString());
            }
            writer.println(String.join(",\n", columns));
            writer.println(");");
            writer.println();
        }

        writer.println("-- Data for table: " + tableName);
        try (Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery("SELECT * FROM " + tableName)) {

            ResultSetMetaData metaData = rs.getMetaData();
            int columnCount = metaData.getColumnCount();

            while (rs.next()) {
                StringBuilder insertSQL = new StringBuilder("INSERT INTO " + tableName + " VALUES (");

                for (int i = 1; i <= columnCount; i++) {
                    Object value = rs.getObject(i);
                    if (value == null) {
                        insertSQL.append("NULL");
                    } else {
                        String stringValue = value.toString();
                        if (value instanceof String) {
                            stringValue = stringValue.replace("'", "''");
                            stringValue = stringValue.replace("\\", "\\\\");
                            insertSQL.append("'").append(stringValue).append("'");
                        } else if (value instanceof java.util.Date) {
                            java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
                            insertSQL.append("'").append(sdf.format(value)).append("'");
                        } else if (value instanceof Boolean) {
                            insertSQL.append((Boolean) value ? "TRUE" : "FALSE");
                        } else {
                            insertSQL.append(value.toString());
                        }
                    }

                    if (i < columnCount) {
                        insertSQL.append(", ");
                    }
                }

                insertSQL.append(");");
                writer.println(insertSQL);
            }
        }
        writer.println();
    }

    private void backupSequences(Connection conn, String tableName, PrintWriter writer) throws SQLException {
        try (Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(
                     "SELECT column_name, column_default " +
                             "FROM information_schema.columns " +
                             "WHERE table_schema = '" + databaseService.getCurrentSchema() + "' " +
                             "AND table_name = '" + tableName + "' " +
                             "AND column_default LIKE 'nextval%'")) {

            while (rs.next()) {
                String columnDefault = rs.getString("column_default");
                if (columnDefault != null && columnDefault.contains("nextval")) {
                    int start = columnDefault.indexOf("'") + 1;
                    int end = columnDefault.indexOf("'", start);
                    if (start > 0 && end > start) {
                        String sequenceName = columnDefault.substring(start, end);
                        writer.println("-- Sequence for SERIAL column");
                        writer.println("DROP SEQUENCE IF EXISTS " + sequenceName + " CASCADE;");
                        writer.println("CREATE SEQUENCE " + sequenceName + ";");
                        writer.println();
                    }
                }
            }
        }
    }

    private String cleanupDefaultValue(String defaultValue) {
        if (defaultValue == null) return "";

        if (defaultValue.contains("nextval")) {
            return "";
        }
        String cleaned = defaultValue.replaceAll("::[a-zA-Z_]+", "");

        return cleaned.trim();
    }

    public BackupResult restoreBackup(File backupFile) {
        BackupResult result = new BackupResult();

        if (backupFile == null || !backupFile.exists()) {
            result.setSuccess(false);
            result.setMessage("Backup file not found: " + (backupFile != null ? backupFile.getPath() : "null"));
            return result;
        }

        System.out.println("Starting restore from: " + backupFile.getAbsolutePath());

        try (Connection conn = databaseService.getConnection()) {
            conn.setAutoCommit(false);

            try (BufferedReader reader = new BufferedReader(new FileReader(backupFile))) {

                StringBuilder sqlScript = new StringBuilder();
                String line;
                int executedStatements = 0;
                int failedStatements = 0;

                while ((line = reader.readLine()) != null) {
                    if (line.trim().startsWith("--")) {
                        continue;
                    }

                    if (sqlScript.length() > 0) {
                        sqlScript.append(" ");
                    }
                    sqlScript.append(line.trim());

                    String currentScript = sqlScript.toString().trim();
                    if (currentScript.endsWith(";")) {
                        String sql = currentScript.substring(0, currentScript.length() - 1).trim();

                        if (!sql.isEmpty()) {
                            System.out.println("Executing SQL: " + (sql.length() > 100 ? sql.substring(0, 100) + "..." : sql));

                            try (Statement stmt = conn.createStatement()) {
                                stmt.execute(sql);
                                executedStatements++;
                                System.out.println("Successfully executed statement " + executedStatements);
                            } catch (SQLException e) {
                                failedStatements++;
                                System.err.println("ERROR executing SQL (" + failedStatements + "): " + e.getMessage());
                                System.err.println("Failed SQL: " + (sql.length() > 200 ? sql.substring(0, 200) + "..." : sql));

                                if (sql.toUpperCase().startsWith("DROP TABLE") &&
                                        e.getMessage().contains("does not exist")) {
                                    System.out.println("Ignoring DROP TABLE error for non-existent table");
                                    executedStatements++;
                                } else {
                                    throw new SQLException("Failed to execute SQL statement " + executedStatements +
                                            ": " + e.getMessage() + " | SQL: " + sql, e);
                                }
                            }
                        }

                        sqlScript = new StringBuilder();
                    }
                }

                conn.commit();

                result.setSuccess(true);
                result.setMessage(String.format(
                        "Backup restored successfully. Executed: %d statements, Failed: %d statements",
                        executedStatements, failedStatements
                ));
                result.setTablesCount(executedStatements);

                System.out.println("Restore completed: " + result.getMessage());

            } catch (SQLException e) {
                try {
                    conn.rollback();
                    System.err.println("Transaction rolled back due to error");
                } catch (SQLException rollbackEx) {
                    System.err.println("Error during rollback: " + rollbackEx.getMessage());
                }

                result.setSuccess(false);
                result.setMessage("Restore failed: " + e.getMessage());

            } catch (IOException e) {
                try {
                    conn.rollback();
                } catch (SQLException rollbackEx) {
                    System.err.println("Error during rollback: " + rollbackEx.getMessage());
                }

                result.setSuccess(false);
                result.setMessage("Error reading backup file: " + e.getMessage());
            }

            conn.setAutoCommit(true);

        } catch (SQLException e) {
            result.setSuccess(false);
            result.setMessage("Database connection error: " + e.getMessage());
        }

        return result;
    }

    public List<File> getAvailableBackups() {
        List<File> backups = new ArrayList<>();

        try {
            Path backupPath = Paths.get(BACKUP_DIR);
            if (Files.exists(backupPath)) {
                try (DirectoryStream<Path> stream = Files.newDirectoryStream(backupPath, "*.sql")) {
                    for (Path entry : stream) {
                        backups.add(entry.toFile());
                    }
                }
            }
        } catch (IOException e) {
            System.err.println("Error reading backup directory: " + e.getMessage());
        }

        backups.sort((f1, f2) -> Long.compare(f2.lastModified(), f1.lastModified()));
        return backups;
    }

    @Setter
    @Getter
    public static class BackupResult {
        private boolean success;
        private String message;
        private File backupFile;
        private int tablesCount;
    }
}